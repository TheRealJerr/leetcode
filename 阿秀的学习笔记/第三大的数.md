

## 第三大的数

leetcode 链接： https://leetcode.cn/problems/third-maximum-number/

问题找到数组中的第三的数，我的第一个思路还是topk问题，就是通过构建一个堆表示当前最大的几个数

时间复杂度 : n * log(k)

思路：

1. 首先将数组的前k个数构建一个小根堆，然后如果新的数，大于堆顶，将堆顶删除，将这个数添加

2. 如果没有，continue

```cpp
class Solution {
public:
    int thirdMax(vector<int>& nums) {
        // 边界判断
        if(nums.size() == 2)
            return std::max(nums[0], nums[1]);
        else if(nums.size() == 1) 
            return nums[0];
        std::priority_queue<int,std::vector<int>,std::greater<int>> pq;// 默认是小根堆
        for(int i = 0;i < 3;i++)
            pq.push(nums[i]);
        
        for(int i = 3;i < nums.size();i++)
        {
            if(nums[i] > pq.top()) 
            {
                pq.pop();
                pq.push(nums[i]);
            }
        }

        return pq.top();
    }
};
```
这是我第一次写的，显然出现了一个问题，就是审题不清晰，这道题还需要我们进行数据的去重，就是同样的数据不能计算两次。

解决方式就是通过hash表进行去重，但是这样可能造成o(n)的空间复杂度的浪费，这里我们不推荐

**所以换一种思路**

因为三很小，我们直接通过设计三个常量来进行表示

```cpp
class Solution {
public:
    int thirdMax(vector<int>& nums) {
        
        long long firs = LONG_MIN, secon = LONG_MIN, thir = LONG_MIN;

        for(int i = 0;i < nums.size();i++)
        {
            int x = nums[i];
            if(x > firs && x < secon)
                firs = x;
            else if(x > secon && x < thir)
            {
                firs = secon;
                secon = x;
            }
            else if(x > thir)
            {
                firs = secon;
                secon = thir;
                thir = x;
            }
        }
        //
        if(firs != LONG_MIN) return firs;
        else return std::max(secon, thir);
    }
};
```

## 最短无序连续数组, 经典

leetcode : https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/

![alt text](image.png)

我直接看到这道题目的一路就是将排好序的数组和这道题目直接对比，对比出的第一个不同的位置和最后一个不同位置的差 + 1就是答案

```cpp
class Solution {
public:
    int findUnsortedSubarray(vector<int>& nums) {

        std::vector<int> copy_nums;
        std::copy(nums.begin(),nums.end(),std::back_inserter(copy_nums));
        std::sort(copy_nums.begin(), copy_nums.end());
        // 找到开始不同的位置
        
        for(auto e : copy_nums) std::cout << e << " ";
        
        std::cout << std::endl;
        int n = nums.size();
        int i = 0;
        for(i = 0;i < n;i++)
        {
            if(copy_nums[i] != nums[i]) break;
        }
        // 
        if(i == n) return 0; // 完全相同

        // 从后往前找

        int j = 0;
        for(j = n - 1;j >= i;j--)
            if(copy_nums[j] != nums[j]) break;
        
        
        return  j - i + 1;
    }
};

```

但是呢，他有希望你是否能够给出一个o(n)时间复杂度的算法，上面算法中利用了std::sort, 他的底层快速排序为n * log(n), 所以现在我们思考如何才能对其进行优化呢？


优化思路： 

什么样的部分我们需要重拍，当前位置前面存在一个比我还大的数，比如[1 3 5 4]

4这个位置现任是错的，因为他的前面有一个5, 从左遍历可以帮助我们找到无序列表的最右端，对吧，

因为我们找到4是错的，但是不能判断5是错的，当我们再次从右向左进行遍历的时候，发现我的后面有

一个比我小的数，就把5找到了。

```cpp
class Solution {
public:
    int findUnsortedSubarray(vector<int>& nums) {
        
        // 从左往右找找到右边界

        int Max = -INT32_MAX;
        int left_edge = 0, right_edge = 0;

        // 右边界
        for(int i = 0;i < nums.size();i++)
        {
            if(Max > nums[i]) right_edge = i;
            else Max = nums[i];
        }
        //左边界
        int Min = INT32_MAX;
        for(int i = nums.size() - 1;i >= 0;i--)
        {
            if(Min < nums[i]) left_edge = i;
            else Min = nums[i]; 
        }

        return left_edge == right_edge ? 0 : right_edge - left_edge + 1;
    }
};
```

总结： 这道题目我们需要定位出矛盾，什么样的位置需要排列，某个位置存在大于我们的数， 或者某个位置后存在小于我们的数，都是矛盾，通过两次o(n)的循环找到矛盾即可。


## 种花问题

题目描述：

假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。

给你一个整数数组 flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false 。

**思路**：

我第一部看到这个问题的时候，我首先想到的就是这道题是一个多状态题目，可以使用的方式肯定是`动态规划`， 但是我试了一下动态规划，似乎不太行，就算行，但是作为一个easy的题目，我认为肯定不会这么复杂。

其实思路很简单，我们遍历，走到一个位置，如果他的前后都没有花，我们就种

```cpp
class Solution {
public:
    bool canPlaceFlowers(vector<int>& flowerbed, int n) {
        int count = 0;

        for(int i = 0;i < flowerbed.size();i++)
        {
            if(flowerbed[i] == 1) continue;
            // 前后有花
            if((i - 1 >= 0 && flowerbed[i - 1] == 1) ||(i + 1 < flowerbed.size() && flowerbed[i + 1] == 1))
                continue;
            ++count;
            flowerbed[i] = 1;
        }
        return count >= n;
    }
};
```

## 三个数的最大乘积

**题目描述**

给你一个整型数组 nums ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。

**思路**

这道题目和找到最大的三个数的区别就是有正负， 情况分析，我们需要三个整数，或者一个正数， 或者两个负数

简单一点的方式就是首先直接排序

最大值只可能是最后三个的乘积，或者前面两个 * 最后一个

```cpp
class Solution {
public:
    int maximumProduct(vector<int>& nums) { 
        std::sort(nums.begin(), nums.end());
        int n = nums.size();
        double max_value = nums[n - 1] * nums[n - 2] * nums[n - 3];
        max_value = std::max(max_value ,(double)(nums[0] * nums[1] * nums[n - 1]) );

        return max_value;
    }
};
```
## 子数组的最大平均数

给你一个由 n 个元素组成的整数数组 nums 和一个整数 k 。

请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。

任何误差小于 10-5 的答案都将被视为正确答案。

 **思路**

 这道题目的本质就是，找到最大的k个数的和

 在遍历的过程中出一个数，进一个数，知道结束。

 很简单

 ```cpp
 class Solution {
public:
    double findMaxAverage(vector<int>& nums, int k) {
        long long sum = 0;
        long long max_sum = 0;
        // 初始化
        for(int i = 0;i < k;i++) sum += nums[i];
        max_sum = sum;

        // 遍历
        int n = nums.size();
        for(int i = k; i < n;i++)
        {
            sum += (nums[i] - nums[i - k]);
            max_sum = std::max(max_sum , sum);
        }
        return static_cast<double>((double)max_sum / k);
    }
};
```

## 非递减数列

给你一个长度为 n 的整数数组 nums ，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。

我们是这样定义一个非递减数列的： 对于数组中任意的 i (0 <= i <= n-2)，总满足 nums[i] <= nums[i + 1]。

思路：

