# 二分查找板块

## 二分查找（经典二分查找）

[leetcode](https://leetcode.cn/problems/binary-search/)

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果 target 存在返回下标，否则返回 -1。

你必须编写一个具有 O(log n) 时间复杂度的算法。


```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while(left < right)
        {
            int mid = left + (right - left) / 2;
            if(nums[mid] >= target) right = mid;
            else left = mid + 1;
        }
        return nums[left] == target ? left : -1;
    }
};
```

## x的平方根

给你一个非负整数 x ，计算并返回 x 的 算术平方根 。

由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。

注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。

```cpp
class Solution {
public:
    int mySqrt(int x) {
        long long left = 0, right = x;
        while(left < right)
        {
            long long mid = left + (right - left + 1) / 2;
            if((long long)(mid * mid) > x) right = mid - 1;
            else left = mid;
        }

        return left;
    }
};
```

## 两数之和II - 输入有序数组

[leetcode](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/)

给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 。

以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。

你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。

你所设计的解决方案必须只使用常量级的额外空间。

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) 
    {
        numbers.insert(numbers.begin(), 0);
        std::vector<int> ret;
        int len = numbers.size() - 1;
        for(int i = 1;i <= len && numbers[i] <= target / 2;i++)
        {
            // 从[i + 1, len]这个区间中找
            int left = i + 1, right = len;
            while(left < right)
            {
                int mid = left + (right - left) / 2;
                if(numbers[mid] < target - numbers[i]) left = mid + 1;
                else right = mid;
            }
            if(numbers[left] == target - numbers[i]) 
            {
                ret = {i, left};
                return ret;
            }
        }   
        return ret; 
        return {};
    }
};
```

## 有效的完全平方数

[leetcode](https://leetcode.cn/problems/valid-perfect-square/description/)

给你一个正整数 num 。如果 num 是一个完全平方数，则返回 true ，否则返回 false 。

完全平方数 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。

不能使用任何内置的库函数，如  sqrt 。

```cpp
class Solution {
public:
    int mySqrt(int num)
    {
        long long left = 0, right = num;
        while(left < right)
        {
            long long mid = left + (right - left) / 2;
            if(mid * mid < num) left = mid + 1;
            else right = mid;            
        }
        return left;
    }
    bool isPerfectSquare(int num) {
        long long t = mySqrt(num);
        return t * t == (long long)num;
    }
};
```

## 猜数字大小

我们正在玩猜数字游戏。猜数字游戏的规则如下：

我会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。

如果你猜错了，我会告诉你，我选出的数字比你猜测的数字大了还是小了。

你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有三种可能的情况：

-1：你猜的数字比我选出的数字大 （即 num > pick）。
1：你猜的数字比我选出的数字小 （即 num < pick）。
0：你猜的数字与我选出的数字相等。（即 num == pick）。
返回我选出的数字。

```cpp
class Solution {
public:
    int guessNumber(int n) {
        // 1 ~ n中间的数
        int left = 1, right = n;
        while(left < right)
        {
            int mid = left + (right - left) / 2;
            if(guess(mid) == 0) return mid;
            else if(guess(mid) == 1) left = mid + 1;
            else right = mid;
        }

        return left;
    }
};
```

## 判断子序列

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

进阶：

如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？


```cpp
// 这一版不是双指针的版本
class Solution {
public:
    bool isSubsequence(string s, string t) 
    {
        // 直接双指针匹配即可
        int l = 0, r = 0;
        for(r = 0; r < t.size(); r++)
        {
            if(l < s.size() && t[r] == s[l]) l++;
        }    

        return l == s.size();
    }
};
```

## 排列硬币

你总共有 n 枚硬币，并计划将它们按阶梯状排列。对于一个由 k 行组成的阶梯，其第 i 行必须正好有 i 枚硬币。阶梯的最后一行 可能 是不完整的。

给你一个数字 n ，计算并返回可形成 完整阶梯行 的总行数。

```cpp
class Solution {
public:
    int arrangeCoins(int n) {
        // 对于n行，他的总数是(n + 1) * n / 2
        // 对于n + 1行, 他的总数是(n + 2) * n / 2; 
        // 我们需要找到临界点的n
        int left = 1, right = n;
        while(left < right)
        {
            long long mid = left + (right - left + 1) / 2;
            long long tmp = (mid + 1) * mid / 2;
            if(tmp > n) right = mid - 1;
            else left = mid;
        }

        return left;
    }
};
```


## 供暖器（经典）

[leetcode](https://leetcode.cn/problems/heaters/)

冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。

在加热器的加热半径范围内的每个房屋都可以获得供暖。

现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。

注意：所有供暖器 heaters 都遵循你的半径标准，加热的半径也一样。

**思路**

这道题我们应该通过房屋找热水器，也就是对于每个房屋，我们可以通过二分查找的方式找到离他最近的热水器。


```cpp
class Solution {
public:
    int findRadius(vector<int>& houses, vector<int>& heaters) 
    {
        // 每一个房屋，都应该找到离他最近的供暖器
        sort(heaters.begin(), heaters.end());
        int minLen = 0; // 最短的最大值
        for(auto house : houses)
        {
            // 通过二分找到最近的供暖器
            // 边界
            
            int curMinLen = INT32_MAX;
            if(house <= heaters.front()) curMinLen = heaters.front() - house;
            else if(house >= heaters.back()) curMinLen = house - heaters.back();
            else 
            {
                int left = 0, right = heaters.size() - 1;
                while(left < right)
                {
                    int mid = left + (right - left) / 2;
                    if(heaters[mid] < house) left = mid + 1;
                    else right = mid;
                }
                //
                curMinLen = std::min(heaters[right] - house, house - heaters[left - 1]);
            } 

            
            // 更新
            minLen = std::max(minLen, curMinLen);
        }
        return minLen;
    }
};
```

