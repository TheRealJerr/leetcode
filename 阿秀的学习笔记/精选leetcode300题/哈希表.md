# 哈希表板块

## 快乐数
[leetcode](https://leetcode.cn/problems/happy-number/description/)

编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」 定义为：

对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果这个过程 结果为 1，那么这个数就是快乐数。
如果 n 是 快乐数 就返回 true ；不是，则返回 false 。


**思路**

我们判断要么出现循环，要么出现一，不可能不出现循环且不唯一，因为不可能一直增大。对于三位数及以上，每个为的平方和最多为99 * n, 显然是有限的。

```cpp
class Solution {
public:
    int getNextNum(int n)
    {
        int ret = 0;
        while(n)
        {
            int tmp = n % 10;
            n /= 10;
            ret += (tmp * tmp);
        }
        return ret;
    }
    bool isHappy(int n) {
        // 看是否存在循环
        std::unordered_set<int> cache;
        while(n != 1)
        {
            cache.insert(n);
            n = getNextNum(n);
            if(cache.count(n)) return false;
        }

        return true;
    }
};
```

## 计数质数

(leetcode)[https://leetcode.cn/problems/count-primes/description/]


给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。

**思路**

这是一道很好的题目，利用厄拉多塞筛法, 可以看看这个思路，最经典的就是从i * i向后填充，保证了时间复杂度为o(n)左右吧

```cpp
class Solution {
public:

    int countPrimes(int n) 
    {
        std::vector<int> isPrime(n, 1);
        int count = 0;
        for(long long i = 2; i < n;i++)
        {
            if(isPrime[i] == 1) 
            {
                count++;
                long long j = i * i;
                for(;j < n;j += i)
                    isPrime[j] = 0;
            }
        }
        return count;
    }
};
```

## 同构字符串

给定两个字符串 s 和 t ，判断它们是否是同构的。

如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。


## 单词规律

(leetcode)[https://leetcode.cn/problems/word-pattern/description/]

给定一种规律 pattern 和一个字符串 s ，判断 s 是否遵循相同的规律。

这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 s 中的每个非空单词之间存在着双向连接的对应规律。

 

示例1:

输入: pattern = "abba", s = "dog cat cat dog"
输出: true
示例 2:

输入:pattern = "abba", s = "dog cat cat fish"
输出: false
示例 3:

输入: pattern = "aaaa", s = "dog cat cat dog"
输出: false
 
```cpp
class Solution {
public:
    bool wordPattern(string pattern, string s) {
        std::unordered_map<char,string> map1;
        std::unordered_map<string,char> map2;
        int i = 0; // i表示所处的pattern的下标
        s.push_back(' ');
        string word;
        for(int j = 0;j < s.size();j++)
        {
            if(s[j] != ' ') word.push_back(s[j]);
            else 
            {
                // 得到了word
                if(i >= pattern.size()) return false; // 长度不匹配
                // 处理从左往右
                if(map1.count(pattern[i]) && map1[pattern[i]] != word) return false;
                else if(!map1.count(pattern[i])) map1[pattern[i]] = word; 
                // 处理从右往左
                if(map2.count(word) && map2[word] != pattern[i]) return false;
                else if(!map2.count(word)) map2[word] = pattern[i];
                i++;
                word = "";
            }
        }
        
        return i == pattern.size();
    }
};
```

## 字符串中的第一个唯一字符

给定一个字符串 s ，找到 它的第一个不重复的字符，并返回它的索引 。如果不存在，则返回 -1 。

```cpp
class Solution {
public:
    int firstUniqChar(string s) {
        int arr[26] = { 0 };
        memset(arr,0,26);
        for (auto e : s) {
            ++arr[e - 'a'];
        }
        for(size_t i = 0;i < s.size();i++)
        {
            if(arr[s[i] - 'a'] == 1){
                return i;
            }
        }
        return -1;
    }
};
```

## 最长的和谐数组

和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。

给你一个整数数组 nums ，请你在所有可能的 子序列 中找到最长的和谐子序列的长度。

数组的 子序列 是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到

```cpp
class Solution {
public:
    int findLHS(vector<int>& nums)
    {
        std::map<int,int> Counter;
        for(auto num : nums) Counter[num]++;
        auto it = Counter.begin();
        int maxLen = 0;
        while(it != Counter.end())
        {
            auto next = it;
            ++next;
            
            // 
            if(next != Counter.end() && next->first - it->first == 1) maxLen = std::max(maxLen, it->second + next->second);

            it = next;
        }

        return maxLen;
    }
};
```