# 栈模块


## 155. 最小栈

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

实现 MinStack 类:

- MinStack() 初始化堆栈对象。
- void push(int val) 将元素val推入堆栈。
- void pop() 删除堆栈顶部的元素。
- int top() 获取堆栈顶部的元素。
- int getMin() 获取堆栈中的最小元素。

```cpp
class MinStack {
public:
    MinStack() {
        
    }
    
    void push(int val) {
        hashMap[val].push_back(sk.size());
        sk.push_back(val);   
    }
    
    void pop() {
        hashMap[sk.back()].pop_back();
        if(hashMap[sk.back()].size() == 0) hashMap.erase(sk.back());
        sk.pop_back();
    }
    
    int top() {
        return sk.back();
    }
    
    int getMin() {
        auto it = hashMap.begin();
        auto pos = it->second[0];
        return sk[pos];
    }

private:
    // 常数时间查找那么一定会用到hashMap
    map<int,vector<int>> hashMap;
    std::vector<int> sk;
};
```

## 225. 用队列实现栈

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。

实现 MyStack 类：

void push(int x) 将元素 x 压入栈顶。
int pop() 移除并返回栈顶元素。
int top() 返回栈顶元素。
boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。

```cpp
class MyStack {
public:
    MyStack() {
        
    }
    
    void push(int x) {
        static_que.push(x);
    }
    
    int pop() {
        while(static_que.size() != 1)
        {
            expire_que.push(static_que.front());
            static_que.pop();
        }
        auto res = static_que.front();
        static_que.pop();
        while(!expire_que.empty())
        {
            static_que.push(expire_que.front());
            expire_que.pop();
        }
        return res;
    }
    
    int top(){
        while(static_que.size() != 1)
        {
            expire_que.push(static_que.front());
            static_que.pop();
        }
        auto res = static_que.front();
        static_que.pop();
        expire_que.push(res);
        while(!expire_que.empty())
        {
            static_que.push(expire_que.front());
            expire_que.pop();
        }
        return res;
    }
    
    bool empty() {
        return static_que.empty();
    }
private:
    queue<int> static_que;
    queue<int> expire_que;
};

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj = new MyStack();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->top();
 * bool param_4 = obj->empty();
 */
```

## 682. 棒球比赛

你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。

比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则：

整数 x - 表示本回合新获得分数 x
"+" - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。
"D" - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。
"C" - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。
请你返回记录中所有得分的总和。


```cpp
class Solution {
public:
    int calPoints(vector<string>& operations) 
    {
        vector<int> points(operations.size());
        int cur = 0;
        for(auto& op : operations)
        {
            if(op == "+"){
                points[cur] = points[cur - 1] + points[cur - 2];
                cur++;
            }else if(op == "C"){
                cur--;
            }else if(op == "D"){
                points[cur] = points[cur - 1] * 2;
                cur++;
            }else {
                auto grade = stoi(op);
                points[cur] = grade;
                cur++;
            }
        } 

        int sum = 0;
        for(int i = 0;i < cur;i++) 
        {
            sum += points[i];
            
        }
      
        return sum;   
    }
};
```